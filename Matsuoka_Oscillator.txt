import sys, os
sys.path.append(r'C:\Users\jsalm\Documents\UF\PhD\Spring 2021\BME6938-Neuromechanics\Berkely Modanna\Py Mimicks')

import numpy as np
import scipy as sp
import pylab as plt
from scipy.fftpack import fft,fftfreq
from scipy.integrate import odeint, RK45


        
class Matsuoka():
    g = 9.81
    rfl = 1.1*(2*np.pi)
    cfl = 0.5
    Ttot = 2 # total time in second
    f_s = 1000 # sample frequency (samples/s)
    t_s = np.arange(0,Ttot,1/f_s) #time in s
    t_ms = np.arange(0,Ttot*f_s,1) #time in ms
    
    def __init__(self,initial_cond):
        """Full Matsuoka Neural Oscillator"""
        self.bc = float(2.5) #coefficient adjusts time course of the adaptation (b=0, 0<b<inf, and b=inf)
        self.wc = float(2.5) #strength of the inhibitory connection bewteen the neurons
        #self.oc = float(np.pi/8) #threshold value below which the neuron does not fire
        self.h1 = float(30) #weight of synaptic conjunction 1 (>0 for excitatory, <0 for inhibitory)
        self.h2 = float(30) #weight of synaptic conjunction 2 (>0 for excitatory, <0 for inhibitory)
        self.t1 = float(0.1) #tau: a time constant
        self.m1 = 10
        self.L1 = self.g/(self.rfl**2)
        self.t2 = float(5) #bigT: determine time course of adaptation 
        self.I1 = self.m1*self.L1**2
        self.c1 = 2
        self.condition = True
        self.prev_cond = initial_cond
        self.storeX = [initial_cond]
    def check_condition(self):
        return (self.t2-self.t1)**2 >= 4*self.t2*self.t1*self.bc
        
    @staticmethod
    def dALLdt(X,t,self):
        """
        Integrate

        |  :param X:
        |  :param t:
        |  :return: calculate membrane potential & activation variables
        """

        
        x1, x2, v1, v2, docdt, oc  = X
        
        y1 = max(x1,0)
        y2 = max(x2,0)
        y = y1-y2
        
        dx1dt = (-x1-self.bc*v1-self.wc*y2-self.h1*max(oc,0)-self.h2*max(oc,0)+self.c1)/self.t1  #membrane potential
        dx2dt = (-x2-self.bc*v2-self.wc*y1-self.h1*-min(oc,0)-self.h2*-min(oc,0)+self.c1)/self.t1 #membrane potential
        dv1dt = (y1-v1)/self.t2 #degree of the adaptation n1
        dv2dt = (y2-v2)/self.t2 #degree of the adaptation n2

        
        G1 = 1
        I1 = self.m1*self.L1**2
        T1 = G1*y1
        
        docdt = oc #Pendulum
        docdtdt = T1/I1-self.cfl*docdt-self.g*np.sin(oc)/self.L1 #Pendulum
        
        return dx1dt, dx2dt, dv1dt, dv2dt, docdtdt, docdt
        
    def solve(self):
        self.check_condition()
        X = odeint(self.dALLdt, self.prev_cond, self.t_ms, tcrit = self.t_ms, args = (self,))
        
        V = X[:,0]
        #m = X[:,1]
        #h = X[:,2]
        #n = X[:,3]
        #ina = self.I_Na(V, m, h)
        #ik = self.I_K(V, n)
        #il = self.I_L(V)
        self.prev_cond = [X[-1,0],X[-1,1],X[-1,2],X[-1,3],X[-1,4]]
        self.storeX.append([X[-1,0],X[-1,1],X[-1,2],X[-1,3],X[-1,4]])
        
        return X
        
    def plot_store(self,n_name):
        """
        Main demo for the Hodgkin Huxley neuron model
        """
        X = np.array(self.storeX)
        x1 = X[0]
        x2 = X[1]
        v1 = X[2]
        v2 = X[3]
        y1 = X[4]
        y2 = X[5]
        
        fig = plt.figure("Action Potential Graph of {}".format(n_name),figsize=(20,10))
        plt.subplot(3,1,1)
        plt.title('Matsuoka Plot')
        plt.plot(self.t, x1, 'n1')
        plt.plot(self.t, x2, 'n2') 
        plt.ylabel('V (mV)')
        plt.subplot(3,1,2)
        plt.plot(self.t, v1, 'c', label='adaptation n1')
        plt.plot(self.t, v2, 'y', label='adaptation n2')
        plt.ylabel('adaption rate')
        plt.legend()

        plt.subplot(3,1,3)
        plt.plot(self.t, y, label = 'input value')
        plt.xlabel('time (ms)')
        plt.ylabel('I (mA)')
        plt.tight_layout()
        fig.savefig(r'C:\Users\jsalm\Documents\UF\PhD\Spring 2021\BME6938-Neuromechanics\save_bin\{}.png'.format(n_name),dpi=200,bbox_inches='tight')
        plt.close()
        
        return V
 
    

        
    
if __name__ == "__main__":
    #website: https://nbviewer.jupyter.org/github/demotu/BMC/blob/master/notebooks/MuscleModeling.ipynb
    initial_cond = [np.pi/7,np.pi/14,0,0, 0,np.pi/8]
    mod = Matsuoka(initial_cond)
    X = mod.solve()
    mod.plot_store('matsuoka model')
    
    